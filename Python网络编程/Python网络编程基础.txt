python语言进行网络编程的基础只是，主要内容包括网络基础知识，高级网络操作，
web　services,解析hml,e-mail服务，ftp,
使用python操作符数据库,ssl,几种服务器端框架(包括socket服务器，simplexmlRPCserver,cgi和mod_python)
以及多任务处理(包括forking,线程和异步通信)等

学习一种语言，阅读别人的程序是一种非常好的方法

第１部分
底层网络

第１章
客户/服务器网络介绍

不同计算机之间的通信，使用最广泛的是tcp/ip
(Transmission Control Protocol/Internet Protocol)
tcp/ip是标准的协议，它可以使世界范围内的计算机通过Internet或本地的网络通信


两个Internet(Internet protocols)之间的区别：
TCP,UDP

介绍域名系统(Domain Name System(DNS))的操作
DNS可以把文字形式的计算机名字转换成数字地址。

一些底层操作，既可以应用于客户端，也可以应用于服务器


１．１　理解TCP基础

tcp/ip　事实上是一些协议(protocols)的合集。
当前大多数使用中的通信都使用tcp协议

Internet是在一些共享的线路上发送数据的。

可以在本地计算机上同时运行着几个应用程序，如web浏览器，
即时通讯软件和e-mail程序
只需通过一条单一的Modem或DSL线路来连接互联网。
上面所有的程序都共享这个连接。用户不会察觉这个共享的发生


为了实现共享，tcp是通过把你要发送的数据流分解成很多小信息包
在Internet上传输的(也许还伴有其他程序的信息包)，而这些信息包到了
接收这的地方会再次重新合成在一起。
通过分解成小的信息包，Internet连接就会用很少的时间来发送数据
的每一个比特(bit),而其他程序的信息也可以同时被发送

１．１．１　　寻址


为了实现这个信息包计划，TCP必须要考虑一些细节问题，
首先，tcp要能识别远程的及其。
基于tcp/ip的网络，每台机器都有一个唯一的ip地址，
这个ip地址看上去类似192.168.1.1
只要知道了接收者机器的ip地址，信息就可以传送过去

其次，tcp需要知道是与远程及其上运行的哪个程序通信。
究竟是哪个程序应该接收传过来的数据。为了实现这个目的，tcp使用端口号
每个程序使用一个唯一的端口号。这些端口号有时是事先知道的，
有时是随机指定的，所以，每个TCP连接的端点是由一个ip地址和一个
端口号来唯一标识的。

尽管有了ip地址和端口号，tcp就能很好地工作，还有了DNS
当想要和一个远程机器建立连接的时候，可以申请连接该机器ip地址
相对应的DNS,比如www.apresss.com


DNS会提供一个ip地址，接下来就可以建立连接了。

python在程序中经常隐藏DNS层，很多时候不需要知道它的存在

１．１．２　可靠性


Modem有可能改变了数据的几个字节，某个路由器或丢失了一两个信息包‘
系统或许收到了顺序错误的信息包；
一个信息包或许收到了两次；再或许一个主要的网路电缆被切断

tcp是一个可靠的协议，除非整个网络出现了问题，数据将被完好地按
原样正确地传送到另外一端。这个可靠性是通过以下几个规则来实现的


１．为了防止数据在传输的股从横中被损坏，每个信息包都包含一个校验码。
这个校验码就是一个用来保证信息包在传输过程中没有被更改的代码。
当信息包到达目的地的时候，接收方会对比教研和收到的信息中的数据
如果校验码不对，该信息包被省略

２．为了防止信息包丢失，tcp会要求接收方每收到一个信息包
都反馈一下。如果接收方没有提供反馈，发送方会自动重发一次。
由于系统自动处理这个问题，所以程序的开发者根本不用知道
问题的出现。TCP会一直试着发送信息包，一直到接收这收到为止。
或者它会判断网络连接短路，并在程序中返回一个错误提示


３．　为了防止信息包重复或顺序错误，tcp每传送一个信息包都会
传送一个序号。接收方会检查这个序号，确保收到该信息包，并把
全部信息包顺序重新合并。
同时，如果接收方看到了一个已经看多的序号，则该信息包会被丢弃

１．１．３　　路由

为了能使信息包顺利地从本地机器传送到远程服务器上，信息包通常会
经过很多的网络。它们也许先通过本地的DSL到达电话公司，
接着本地城市的一个Internet提供上，
然后到达目的地。

在此期间的每一站，来自其他成千上万计算机的信息包也在一起被传输。
在Internet上负责接收信息包并决定如何把它们传输到目的地设备叫路由器。
可以用一些指令(traceroute,mtr)来查看本地的信息在Internet上传输
时经过了哪些路由器

当路由器断掉时，程序察觉到。当路由器线路拥挤的时候，信息包
有可能丢失，传输的性能也会很差，有时连接又会得到全面的服务，
有时连接速度又会很快

１．１．４　安全

路由器和本地网络的一个重要功能是安全。

因为信息包在Internet上传输的时候，是通过共享的网络传输的，
所以任何有权使用网络的人(只要有台笔记本电脑和一个网卡)
都能看到

这些信息还有可能被插入或改写。

在Internet上传输着一些重要的数据。
还有一个潜在的安全风险是你的连接有可能被拦截而转向另外一台机器。

当前最流行的方法是Secure Sockets Layer(SSL)和Transport　Layer
Security(TLS).
SSL一般是在TCP连接之上的，与程序代码混合在一起，
它提供服务器的认证(所以知道正在和谁通话)
加密(所以其他人都不能看到你的通信)和数据完整型(在没有觉察的情况下，
传输途中的信息包没有人能够修改)

TLS的原理和SSL，类似，只包含在协议堆栈(protocol stack)中

安全性已经越来越重要了，而且认清传统不加密连接的缺点是至关重要的，还应该
明白如何去高效地处理这种情况


１．２　使用客户/服务器模式

tcp/ip对于客户/服务器类型的通信很有帮助。
在客户/服务器结构下，服务器一直在侦听来自客户端的请求，
有请求后，就建立连接来处理它们


例如，当打开一个浏览器并访问www.google.com，浏览器会连接
www.google,com的服务器，并请求访问"/"页：
这个"/"表示该站点的首页。
服务器按顺序找到这一页，并把它传送回你的客户端，接着你的
浏览器就能按照一定的格式显示出来。
一个关键的问题是，客户端总是最开始申请连接的一端，服务器则是
等待客户端连接的一端。

1.2.1 服务器端端口好

为了和一个远程的程序通信，必须知道它的IP地址和端口号。找出IP
地址很简单(只要通过DNS就能得到www.google.com的IP地址)
或许会想要知道怎样才能找到web服务器的端口号

在客户/服务器模式中，服务器通常是侦听一个端口号。
web服务器侦听80端口。web浏览器知道www.google.com端口来获得信息

事实上，在www.iano.org上有一份国际因特网地址分配位于委员会
(Internet Assigned Numbers Authority,IANA)
委会的官方已分配的端口列表。
在linux或unix系统中，还可以在/etc/services下找到这个列表


编写一个服务器，它的服务不在这个列表上，就应该选择一个比1024大
而且你的机器上没有被占用的端口号。
这样可以尽量避免和其他服务冲突。端口号最大可以为65535

在linux或unix系统上，只有系统管理员才能请求访问一个小于1024的端口


１．２．２　客户端端口号


通常，客户端的端口号，一般情况下，客户端会由操作系统随机挑一个端口号

客户端的系统会挑选一个保证没有被使用的
被称为"短命"的端口号，
当服务器收到一个连接请求的时候，请求中带有客户端的端口号，数据会
被传输到该端口上。因此，服务器可以和客户端您挑选的任意端口很好地工作


１．３　理解UDP


UDP，它被用来从一个系统向其他的系统传送非常短的消息。
它只提供一个保证：那就是收到的数据是完整的。
它既不能保证数据是否真的能收到，也不能保证数据是不是只接收一次，
还不能保证收到的信息次序是否和发送时候一致。
但是只要没有受到攻击者绕过安全措施后的攻击，
通过UDP接收的数据通常都会是完整的。


UDP的优点是，因为它不提供上面那些保证，所以要比TCP低级，
tcp建立和关闭连接要花费时间，而UDP对连接没有什么概念，
所以不存在花费时间关闭连接的问题


通常UDP会用在客户端向服务器申请一个比特的信息，如果没有
收到答复会继续申请。用得最广的UDP应用软件是DNS系统。
因为客户端通常只需要发送一个简答的请求，并收到一个同样
简单的回到，UPD非常适合这个任务


UDP还常被用在流式的音频和视频应用软件，
因为UDP只是偶尔丢弃一个信息包，而TCP会过于严格地处理那些被丢弃的
信息博爱，这样音频效果就差很多。
许多游戏和网络文件系统，例如NFS(Need for Speed，极品飞车)
Samba也大量用到了UDP


还有一些选择协议的时候，该用TCP还是UDP的指导方针。
这些方针可能不会涵盖所有的情况，还是


应该用tcp,如果

１．需要一个可靠的数据传输，以确保你的数据完整无缺地到达目的地
２．你的协议需要不止一个请求和服务器的回答
３．你要发送较多的数据
４．　初始连接出现短暂的延迟是可以容忍的


用UDP,如果

１．不太关心信息包是否到达不太在意信息包到达的顺序是否正确，
再或者可以自己察觉这些问题并自己解决

２．你的协议只包括基本请求和回答

３．你需要尽快建立网络会话
４．只传送很少一部分数据。UDP的限制是一个信息包不超过64Kb的数据，
通常人们只用传送1KB一下的数据


１．４　理解物理传输和以太网

tcp/ip有一个优点，就是可以在不同的物理网络硬件之间传送数据。
比较常见的，以太网，端对端(PPP,Peer-Peer Protocol)
拨号连接，令牌环网络，DSL连接，cable modems连接
的网络，人造卫星连接，移动电话以及如T1那样的专线连接

以上这些不同的网络连接都有自己读到的特点，同时还具有共同的特点
例如：端对端连接，通常被用来连接两个单独的机器，而其他连接，
例如：以太网，主要用于连接一个地点的多个机器

有时，开发人员利用某个特殊网络传输的专门属性。而这些属性很多
是属于TCP/IP层的


以太网是当今应用最广泛的物理传输类型，很多不同的协议都可以运行在
以太网上。它也有一些唯一的特性是应用程序开发人员感兴趣的。
最主要的一个是它可以向本地网络所有的工作站广播信息包。

这个特性可以被用来给一个已有的服务做广告，向那些设计好的
终端广播，也可以向所有的个人计算机广播警告信息


一个通过tcp/ip连接以太网的计算机有一个和该网络接口相关的
ip地址。它与一个本网络的机器通信时，
只要直接向该计算机发送信息就你可以。如果要和网外的，在Internet
上的其他机器通信，就必须把信息先发送到一个本地网络上的路由器
然后由路由器决定信息包该方向哪里


为了知道哪些机器是本地的，哪些是远程的，网络软件会检查原计算机
和目的计算机IP地址的头几位(最有效部分)是不是相同。
每个网络接口上都有网络掩码表明需要比较几位。如果比较失败了，
开始的几位是不同的，那么信息包必须经过路由器。其他在范围
之内的计算机利用广播或直接传输则可以直接达到


１．５　　python网络编程

用python编写网路程序的时候，会哟两种情况：
１．有些程序是可以利用python中已经有一些协议模块(例如http,ftp)来写

２．而有些程序则需要自己写协议

１．５．１　　底层接口


python提供了访问底层操作系统socket接口的全部方法，需要的时候
这些接口可以提供功能。它还提供一些用于加密和认证通信的服务，
例如：ssl/tls/如果用c语言编写网络城西，会发现python的socket服务
与c类似　


１．５．１．1基本客户端操作

这是在现实世界中能找到的，可以运行的网络协议实现的最小程序。
它实现的是Gopher协议，一种web出现之前在Internet上非常流行的
协议。这个程序需要两个命令行参数：主机名和文件名，
实现从主机上请求相关文档的功能


操作很简单。它通过调用socket.socket()来建立一个Socket。
参数告诉系统需要一个Internet socket来进行TCP通信。
接着，程序连接远程主机并提供文件名。最后获得响应后，在屏幕上打印出啦

１．５．１．２　错误和异常

python会自动检查错误，并在有错误发生时产生异常。
python会检测到错误并产生一个socket.gaierror异常(请注意，
相关的文字和数字也许不同)
因为程序并没有特殊处理这个异常，所以程序会终止并打印出错的地方
和具体错误。

python中的send()函数，但是sendall()函数更方便。
如果有错误，它会产生异常；否则，则表明信息发送成功


１．５．１．３　　文件类对象

python中，文件对象的操作方法，reanline(),write(),read()等

python库支持文件和文件类对象。socket对象则不提供类似的接口，


python的确提供了一个makefile()函数来生成使用的文件类对象

makefile()函数有两个参数：
１．操作文件类的模式和缓存(buffering)的模式。操作文件类的模式辨明
你是只读，只写或既读又写("rw")

缓存主要用在磁盘文件，但是对于交互式的网络程序，它可能会阻碍程序的
运行，所以最好通过设置为０来关上它


既然能得到文件类对象，就可以用熟悉的方法。

write()和readline()它们的功能和一般的文件对象是一样的

１．５．１．４　基本服务器操作

第一件事就是调用socket.socket()函数来建立一个socket
接着为了运行，把socket设置成可复用的(reusable)
这个设置是可选的，

下一步绑定一个端口，这里选择端口51423
可以选择任何一个大于1024的端口。主机设置成空字符串，这样程序可以
接受来自任意地方的连接。接着调用listen()函数，这表明
已经开始等候来自客户端的连接了，同时设定每次最多只有一个等候处理
的连接。真正的服务器会允许一个很高的数字


主循环从对accept()函数调用的开始。程序会在连接了一个客户端后
马上停止。当某个客户端连接的时候，accept()返回两个信息：
一个新的连接客户端的socket和客户端的ip地址，端口号

这个例子中，使用了文件类对象，所以它的工作方式和前面的例子相似。
服务器接着显示出一些介绍性信息，从客户端读一个字符串，显示
一个应答，最后关闭客户端socket.
关闭socket很重要，否则客户端将不知道服务器已经结束通信，
而在服务器上会堆积很多旧的连接。当使用文件类对象的时候，
必须关闭文件对象和socket对象

首选需要运行服务器程序。然后再在终端或telnet应用程序
并连接localhost的51423端口

好像没有编写telnet协议，但是telnet客户端你也能
通信，可以进骨干这个基本服务器程序可以运行，但是它
没有什么用处


１．５．２　高级接口


经常使用的HTTP或imap,可能不需要编写这个底层的网络程序。。
python提供了很多协议模块，它们可以很大程度上简化编程任务

例如，不用自己编写代码来解析和理解http　header，
python中的httplib模块可以完成这个


gopherlib模块负责建立socket和连接，事实上，它甚至还负责
在返回send_selector()前调用makefile()

python中还有更高级的模块，为了处理url,python提供的模块
可以让你的代码和几种协议一起工作
１．６　总结


tcp/ip协议可以用于多种不同的传输,了；如：modems连接的网络和
以太网。每一个终端是靠唯一的IP地址和端口号来区分的

服务器通过一些事先知道的端口来侦听连接。当一个客户端连接时，
它的操作系统通常会选择一个事先不知道的端口号

有两种常用的数据传输协议：tcp,可以提供可靠性和完整的会话；
udp，用于小且简短但是快速的会话


大都数人用python编写网络程序，要么自己设计协议，要么用一些内置的
模块来实现一些已经存在的协议

对那些自己设计协议的人来说，python提供了全面的socket接口


第二章　网络客户端


编写使用网络服务的程序时，会发现经常要写网络客户端程序。如何在客户端实现一个应用程序协议。
如果Python没有一个可以实现想要的协议的模块，
或想要修改或扩展一个已经存在的Python模块的


２．１　理解socket


socket是操作系统中I/O系统的延伸部分，它可以使进程和机器之间的通信成为可能。
如果想完全地理解socket在当前系统上是如何工作的，
open(),read(),write(),close()。文件描述符一般是指一个文件或某个类似文件的实体


把对网络的支持加入操作系统，是一种扩展现有文件描述符结构的方法来实现的。
新的系统调用被加入并和socket一起工作，而很多现有的系统调用同样能和socket一起工作
一个socket允许您使用标准的操作系统和其他的计算机，以及您自己机器上的不同进程来通信

在某些方面，socket可以被看成一个标准的文件描述符。
在unix类的平台上，read(),write(),dup(),dup2(),close()这样的系统调用会像标准文件描述符那样为
socket工作。程序并不需要知道它正把数据写进一个文件，终端或一个TCPz连接


socket的确存在一些不同的工作方式。最明显的就是建立socket的方法。很多文件是通过调用open()函数来打开的，
但是socket是通过socket函数来建立的，并且还需要另外的调用来连接和激活它们。
recv()和send()这两个系统调用和read()和write()极为相似

send()和recv()调用提供了socket额外特有的功能

Python通过socket模块访问操作系统socket库的接口。建立socket的时候，只需要调用这个模块的函数和常量


2.2 建立socket

对于一个客户端程序来说，建立一个socket需要两步：
１．首先，需要建立一个实际的socket对象
２．　其次，需要把它连接到远程服务器上


在建立socket对象的时候，需要告诉系统两件事情：１．通信类型和协议家族。

通信类型指明了用什么协议来传输数据。协议的例子包括IPv4(当前的Internet标准)
IPv6(将来的Internet标准)
IPX/SPX(NetWare)和AFP(Apple文件共享)

目前为止，最通用的是IPv4,协议家族则定义数据如何被传输


Internet通信，通信类型基本上都是AF_INET(和IPv4对应)协议家族一般是表示TCP通信的SOCK_STREAM或
表示UDP通信的SOCK_DGRAM.

对于TCP通信，建立一个socket连接，一般用类似如下的代码


s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)


连接socket,一般需要提供一个tuple,它包含远程主机名或IP地址和远程端口。

连接一个socket一般用类似如下的代码


s.connect(("www.example.com",80))


import socket

print("Creating socket....")


s = socket.socket()

注意，c语言的connect()函数需要远程计算机的ip地址，在python中，socket对象的connect()函数会根据
需要利用DNS把域名自动地转化为IP地址。但对端口号则不是这样


２．２．１　旋转端口号

大多数操作系统都会附带提供一份已知服务器端口号的列表，可以查询。Python的socket库包含一个getservbyname()的函数
它可以自动地查询。在Unix系统中，总是可以在/etc/services目录下找到这样的列表

为了查询这个列表，需要两个参数：协议名和端口名。

端口名是一个字符串，例如：http可以被转换为一个端口号。

2.2.2 从socket获取信息


一旦建立了一个socket连接，就可以从它那里得到有用的额信息

报错信息

第一条将显示本身的IP地址和端口号；
第二条将显示远程机器的IP地址和端口号

对于客户端来说，端口号是由操作系统分配的(也许是随机的)
所以，会发现每次运行这个程序的时候，端口号都不一样


２．３　利用socket通信

现在和socket的通信已经建立起来了，是利用它发送和接收数据的时候了
python提供了两种方法：socket对象和文件类对象。

socket对象提供了操作系统的send(),sendto(),recv()和recvfrom()

调用的接口。文件类对象提供了read(),write()和readline()这些更典型的python接口


有一些特殊的需求的时候，socket对象特别有用。例如：读写数据时，需要协议可以详细地控制时，
使用二进制协议传送固定带下数据时，数据超时需要特殊处理时；或是任何不止需要简单读写时，
当你编写UDP程序的时候，socket对象同样是很好的选择

文件类对象一般用于面向线性的协议，因为它能通过提供的readline()函数自动大多数的解析。
然而，文件类对象一般只对TCP连接工作得很好，对UDP连接反而不是很好。


这是因为TCP连接的行为更像是标准的文件，它们保证数据接收的精确性，
并且和文件一样是以字节流形式运转的。而UDP并不像文件那样以字节流形式运转。
相反，它是一种基于信息包的通信。文件类对象没有办法操作每个基本的信息包，
因而建立，发送和接收UDP信息包的基本机制是不能工作，并且错误检查也是很困难的


２．４　　处理错误

在python中，当网络出现错误的时候，socket会出现异常。

具体的错误反馈取决于你的应用程序

２．４．１　socket异常

不同的网络调用会产生不同的异常。当处理socket对象时，如何捕获每一个普通的异常，

１．想要连接的主机名
２．服务器上的端口号或名字
３．　想从服务器请求的文件。

程序将连接上服务器，针对所请求文件的每个女子发送一个简单的http请求，显示结果

在整个过程中，它将尝试处理各种类型潜在的错误

异常处理只是简单地打印出一个友好的信息并终止运行。它捕获所有在这个例子中可能产生的和网络相关的
异常。Python的socket模块实际上定义了４种可能出现的异常：

１．与一般I/O和通信问题有关的socket.error
2. 与查询地址信息有关的socket.gaierror;
3. 与其他地址错误有关的socket.herror(和c语言中的h_error相关)
４．与在一个socket上调用settimeout()后，处理超时有关的socket.timeout


２．４．２　遗漏的错误

异常不是由sendall()函数产生的，而是由shutdown()函数产生的
sendall()函数立刻返回，但是shutdown()会一直等待，直到它能给你返回一个精确的退出代码


２．４．３　　文件类对象引起的错误


可以使用makefile()函数从socket得到一个文件类对象。
实际上，这个文件类对象调用实际的socket，所以由文件类对象产生的异常和socket自己的send()
和recv()函数产生的是一样的

注意对flush()的调用，从技术层面上来看，因为对makefile()的调用没有指定缓冲器(buffer)
所以这个调用并不是必须的，

２．５　　使用UDP

UDP通信几乎不使用文件类对象，因为它们往往不能为数据如何发送和接收提供足够的控制


上面的例子需要两个命令行参数：一个主机名和一个服务器的端口号。

它将连接服务器，接着提示输入一行要发送的文字。数据被发送后，它就进入了一个无限循环来等待回复。
因为无法知道什么时候服务器结束发送回复，

UDP和TCP客户端的区别：

１．当socket被建立的时候，程序调用的是SOCK_DGRAM,而不是SOCK_STREAM;
这就会向操作系统提示socket将使用UDP通信，而不是TCP

2.对socket.getservbyname()的调用寻找的是UDP端口号，而不是TCP的。
一个端口号对协议来说是特殊的，所以即使TCP使用119端口，一个完全不同的UDP应用程序也可以使用同一个端口

３．　程序没有办法探测到服务器什么时候发送完成。这是因为其实这没有实际的连接。。
对connect()的调用只是初始化了一些内在参数。同时，服务器也许不会返回任何数据，或数据
也许在传输过程中丢失，程序并没有智能地判断出这个问题，


２．６　总结


网络通信的基本接口是socket,它扩展了操作系统的基本I/O到网络通信。
socket可以通过socket()函数来建立，通过connect()函数来连接，
得到了socket，可以确定本地和远程端点的IP地址和端口号。
socket对不同的协议来说都是一种通用的接口，它可以处理TCP和UDP通信


python提供了两种和socket工作的接口：用于UDP和高级TCP目的标准socket接口，
以及用于简单TCP通信的文件类接口



第３章　网络服务器



前面编写网络客户端，建立一个socket,连接到一个服务器，接着和服务器通信

如何编写网络服务器。服务器的特点是等待来自客户端的请求，发送应答。
通常来说，服务器可以做任何事情，从分发web页面到交换e-mail.

最明显的是建立socket.在客户端频繁发生的突发事件。如何从头建立一个服务器程序，如何取得
客户端的信息，如何把活动记入日志，以及如何用不同的方式来运行你的服务器

3.1  准备连接
对客户端来说，建立一个TCP连接的过程分两步，包括建立socket对象以及调用connect()来建立一个和服务器的连接

对于服务器，这个过程需要４步：

１．　建立socket对象。
２．　设置socket选型(可选的)
3. 绑定到一个端口(同样，也可以是一个指定的网卡)
４．　侦听连接


3.1.1 建立socket对象

为了建立一个socket对象，使用和客户端中用到的同样的命令

s = socket.socket(sock.AF_INET,sock.SOCK_STREAM)

可以使用和客户端中使用的同一个socket对象



３．１．２　设置和得到socket选项

socket中，可以设置很多不同的选项。其中SO_REUSEADDR.

通常地，在一个服务器进程终止后，操作系统会保留几分钟它的端口，从而
防止其他进程(甚至包括本服务器自己的另外一个实例)在超时之前使用这个端口。如果
您设置SO_REUSEADDR的标记为true,操作系统就会在服务器socket被关闭或服务器
进程终止马上释放该服务器的端口。这样做，

s.setsockopt(socket.SQL_SOCKET,sock.SO_REUSEADDR,1)


Python定义setsockopt()和getsockopt()

setsockopt(level,optname,value)
getsockopt(level,optname[,buflen])

value参数的内容是由level和optname参数决定的。
level定义了哪个选项被使用。

通常情况下是SQL_SOCKET.用的socket选项。它还可以通过设置一个特殊协议号码
来设置协议选项。对于一个给定的操作系统，大多数协议选项都是明确的，

３．１．３　绑定socket

下一步是为服务器要求一个端口号，这个过程称为绑定。

每个服务器程序都有它自己的端口，

为了绑定一个端口，s.bind(('',80))

这条指令请求80端口，它是标准的HTTP(web)端口。然而，操作系统通常约定限制小于1024的
端口号，bind()函数的第一个参数是要绑定的IP地址。它通常为空，是可以绑定到所有的接口和地址

事实上，可以通过调用bind()函数来把客户端socket绑定到一个特定的ip地址和端口号。

想用特定的IP地址，对bind()调用s.bind(("192.168.1.1",80))

3.1.4 侦听连接

在实际接受客户端连接之前的最后一步就是调用listen()函数.这个调用通知操作系统准备接收连接。
它只有一个参数，这个参数指明了在服务器实际处理连接的时候，允许有多少个未决(等待)的连接在队列中等待。作为一个约定
一般设置为５
s.listen(5)


3.2 接受连接

大多数服务器都设计成运行不确定长的时间,客户端一般只有几个连接，并且会运行到任务完成或用户终止它们

通常使服务器连续运行的办法是小心地设计一个无限循环

通常情况下，无限循环是不好的，因为它们会耗尽系统的CPU资源，这里的循环是不同的：
当调用accept()的时候，它只在有一个客户端连接后才返回。
同时，程序停止时，并不使用任何CPU资源。一个停止并等待输入或输出的程序

３．３　处理错误
使用try...finanlly程序块关闭socket

在大型程序汇总，使用try...finanlly来确保socket被关闭


３．４　使用UDP

3.5 使用inetd或xinetd

３．５．１　配置inetd

inetd程序的配置文件/etc/inetd.conf

3.5.5 通过inetd使用UDP

3.6 通过syslog来记录日志
对于服务器管理元，通信状态的一个重要的内容是记录日志文件。

syslog是记录日志的一种普通且可以配置的基础工具。
syslog文件中的每一条日志都会自动记录日期，时间，主机名和程序名



3.6.1 在Python中使用syslog

３．７　避免死锁


第４章域名系统


域名系统(DNS)是一个分布式的数据库，它主要来把主机名转换成IP地址。DNS以及相关系统之所以存在，
１．　它可以使人们更容易记住，如www.apress.com,而不是IP65.215.221.149
2. 它允许服务器改变IP地址，但还用同样的名字

使用PyDNS直接查询DNS

4.1 进行DNS查询

DNS是一个全球的分布式数据库

4.2 使用操作系统查询服务
４．２．１　执行基本查询
４．２．２　执行反向查询


4.3 使用PyDNS进行高级查询

第５章　高级网络操作

p111
