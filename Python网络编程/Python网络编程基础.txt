python语言进行网络编程的基础只是，主要内容包括网络基础知识，高级网络操作，
web　services,解析hml,e-mail服务，ftp,
使用python操作符数据库,ssl,几种服务器端框架(包括socket服务器，simplexmlRPCserver,cgi和mod_python)
以及多任务处理(包括forking,线程和异步通信)等

学习一种语言，阅读别人的程序是一种非常好的方法

第１部分
底层网络

第１章
客户/服务器网络介绍

不同计算机之间的通信，使用最广泛的是tcp/ip
(Transmission Control Protocol/Internet Protocol)
tcp/ip是标准的协议，它可以使世界范围内的计算机通过Internet或本地的网络通信


两个Internet(Internet protocols)之间的区别：
TCP,UDP

介绍域名系统(Domain Name System(DNS))的操作
DNS可以把文字形式的计算机名字转换成数字地址。

一些底层操作，既可以应用于客户端，也可以应用于服务器


１．１　理解TCP基础

tcp/ip　事实上是一些协议(protocols)的合集。
当前大多数使用中的通信都使用tcp协议

Internet是在一些共享的线路上发送数据的。

可以在本地计算机上同时运行着几个应用程序，如web浏览器，
即时通讯软件和e-mail程序
只需通过一条单一的Modem或DSL线路来连接互联网。
上面所有的程序都共享这个连接。用户不会察觉这个共享的发生


为了实现共享，tcp是通过把你要发送的数据流分解成很多小信息包
在Internet上传输的(也许还伴有其他程序的信息包)，而这些信息包到了
接收这的地方会再次重新合成在一起。
通过分解成小的信息包，Internet连接就会用很少的时间来发送数据
的每一个比特(bit),而其他程序的信息也可以同时被发送

１．１．１　　寻址


为了实现这个信息包计划，TCP必须要考虑一些细节问题，
首先，tcp要能识别远程的及其。
基于tcp/ip的网络，每台机器都有一个唯一的ip地址，
这个ip地址看上去类似192.168.1.1
只要知道了接收者机器的ip地址，信息就可以传送过去

其次，tcp需要知道是与远程及其上运行的哪个程序通信。
究竟是哪个程序应该接收传过来的数据。为了实现这个目的，tcp使用端口号
每个程序使用一个唯一的端口号。这些端口号有时是事先知道的，
有时是随机指定的，所以，每个TCP连接的端点是由一个ip地址和一个
端口号来唯一标识的。

尽管有了ip地址和端口号，tcp就能很好地工作，还有了DNS
当想要和一个远程机器建立连接的时候，可以申请连接该机器ip地址
相对应的DNS,比如www.apresss.com


DNS会提供一个ip地址，接下来就可以建立连接了。

python在程序中经常隐藏DNS层，很多时候不需要知道它的存在

１．１．２　可靠性


Modem有可能改变了数据的几个字节，某个路由器或丢失了一两个信息包‘
系统或许收到了顺序错误的信息包；
一个信息包或许收到了两次；再或许一个主要的网路电缆被切断

tcp是一个可靠的协议，除非整个网络出现了问题，数据将被完好地按
原样正确地传送到另外一端。这个可靠性是通过以下几个规则来实现的


１．为了防止数据在传输的股从横中被损坏，每个信息包都包含一个校验码。
这个校验码就是一个用来保证信息包在传输过程中没有被更改的代码。
当信息包到达目的地的时候，接收方会对比教研和收到的信息中的数据
如果校验码不对，该信息包被省略

２．为了防止信息包丢失，tcp会要求接收方每收到一个信息包
都反馈一下。如果接收方没有提供反馈，发送方会自动重发一次。
由于系统自动处理这个问题，所以程序的开发者根本不用知道
问题的出现。TCP会一直试着发送信息包，一直到接收这收到为止。
或者它会判断网络连接短路，并在程序中返回一个错误提示


３．　为了防止信息包重复或顺序错误，tcp每传送一个信息包都会
传送一个序号。接收方会检查这个序号，确保收到该信息包，并把
全部信息包顺序重新合并。
同时，如果接收方看到了一个已经看多的序号，则该信息包会被丢弃

１．１．３　　路由

为了能使信息包顺利地从本地机器传送到远程服务器上，信息包通常会
经过很多的网络。它们也许先通过本地的DSL到达电话公司，
接着本地城市的一个Internet提供上，
然后到达目的地。

在此期间的每一站，来自其他成千上万计算机的信息包也在一起被传输。
在Internet上负责接收信息包并决定如何把它们传输到目的地设备叫路由器。
可以用一些指令(traceroute,mtr)来查看本地的信息在Internet上传输
时经过了哪些路由器

当路由器断掉时，程序察觉到。当路由器线路拥挤的时候，信息包
有可能丢失，传输的性能也会很差，有时连接又会得到全面的服务，
有时连接速度又会很快

１．１．４　安全

路由器和本地网络的一个重要功能是安全。

因为信息包在Internet上传输的时候，是通过共享的网络传输的，
所以任何有权使用网络的人(只要有台笔记本电脑和一个网卡)
都能看到

这些信息还有可能被插入或改写。

在Internet上传输着一些重要的数据。
还有一个潜在的安全风险是你的连接有可能被拦截而转向另外一台机器。

当前最流行的方法是Secure Sockets Layer(SSL)和Transport　Layer
Security(TLS).
SSL一般是在TCP连接之上的，与程序代码混合在一起，
它提供服务器的认证(所以知道正在和谁通话)
加密(所以其他人都不能看到你的通信)和数据完整型(在没有觉察的情况下，
传输途中的信息包没有人能够修改)

TLS的原理和SSL，类似，只包含在协议堆栈(protocol stack)中

安全性已经越来越重要了，而且认清传统不加密连接的缺点是至关重要的，还应该
明白如何去高效地处理这种情况


１．２　使用客户/服务器模式

tcp/ip对于客户/服务器类型的通信很有帮助。
在客户/服务器结构下，服务器一直在侦听来自客户端的请求，
有请求后，就建立连接来处理它们


例如，当打开一个浏览器并访问www.google.com，浏览器会连接
www.google,com的服务器，并请求访问"/"页：
这个"/"表示该站点的首页。
服务器按顺序找到这一页，并把它传送回你的客户端，接着你的
浏览器就能按照一定的格式显示出来。
一个关键的问题是，客户端总是最开始申请连接的一端，服务器则是
等待客户端连接的一端。

1.2.1 服务器端端口好

为了和一个远程的程序通信，必须知道它的IP地址和端口号。找出IP
地址很简单(只要通过DNS就能得到www.google.com的IP地址)
或许会想要知道怎样才能找到web服务器的端口号

在客户/服务器模式中，服务器通常是侦听一个端口号。
web服务器侦听80端口。web浏览器知道www.google.com端口来获得信息

事实上，在www.iano.org上有一份国际因特网地址分配位于委员会
(Internet Assigned Numbers Authority,IANA)
委会的官方已分配的端口列表。
在linux或unix系统中，还可以在/etc/services下找到这个列表


编写一个服务器，它的服务不在这个列表上，就应该选择一个比1024大
而且你的机器上没有被占用的端口号。
这样可以尽量避免和其他服务冲突。端口号最大可以为65535

在linux或unix系统上，只有系统管理员才能请求访问一个小于1024的端口


１．２．２　客户端端口号


通常，客户端的端口号，一般情况下，客户端会由操作系统随机挑一个端口号

客户端的系统会挑选一个保证没有被使用的
被称为"短命"的端口号，
当服务器收到一个连接请求的时候，请求中带有客户端的端口号，数据会
被传输到该端口上。因此，服务器可以和客户端您挑选的任意端口很好地工作


１．３　理解UDP


UDP，它被用来从一个系统向其他的系统传送非常短的消息。
它只提供一个保证：那就是收到的数据是完整的。
它既不能保证数据是否真的能收到，也不能保证数据是不是只接收一次，
还不能保证收到的信息次序是否和发送时候一致。
但是只要没有受到攻击者绕过安全措施后的攻击，
通过UDP接收的数据通常都会是完整的。


UDP的优点是，因为它不提供上面那些保证，所以要比TCP低级，
tcp建立和关闭连接要花费时间，而UDP对连接没有什么概念，
所以不存在花费时间关闭连接的问题


通常UDP会用在客户端向服务器申请一个比特的信息，如果没有
收到答复会继续申请。用得最广的UDP应用软件是DNS系统。
因为客户端通常只需要发送一个简答的请求，并收到一个同样
简单的回到，UPD非常适合这个任务


UDP还常被用在流式的音频和视频应用软件，
因为UDP只是偶尔丢弃一个信息包，而TCP会过于严格地处理那些被丢弃的
信息博爱，这样音频效果就差很多。
许多游戏和网络文件系统，例如NFS(Need for Speed，极品飞车)
Samba也大量用到了UDP


还有一些选择协议的时候，该用TCP还是UDP的指导方针。
这些方针可能不会涵盖所有的情况，还是


应该用tcp,如果

１．需要一个可靠的数据传输，以确保你的数据完整无缺地到达目的地
２．你的协议需要不止一个请求和服务器的回答
３．你要发送较多的数据
４．　初始连接出现短暂的延迟是可以容忍的


用UDP,如果

１．不太关心信息包是否到达不太在意信息包到达的顺序是否正确，
再或者可以自己察觉这些问题并自己解决

２．你的协议只包括基本请求和回答

３．你需要尽快建立网络会话
４．只传送很少一部分数据。UDP的限制是一个信息包不超过64Kb的数据，
通常人们只用传送1KB一下的数据


１．４　理解物理传输和以太网

tcp/ip有一个优点，就是可以在不同的物理网络硬件之间传送数据。
比较常见的，以太网，端对端(PPP,Peer-Peer Protocol)
拨号连接，令牌环网络，DSL连接，cable modems连接
的网络，人造卫星连接，移动电话以及如T1那样的专线连接

以上这些不同的网络连接都有自己读到的特点，同时还具有共同的特点
例如：端对端连接，通常被用来连接两个单独的机器，而其他连接，
例如：以太网，主要用于连接一个地点的多个机器

有时，开发人员利用某个特殊网络传输的专门属性。而这些属性很多
是属于TCP/IP层的


以太网是当今应用最广泛的物理传输类型，很多不同的协议都可以运行在
以太网上。它也有一些唯一的特性是应用程序开发人员感兴趣的。
最主要的一个是它可以向本地网络所有的工作站广播信息包。

这个特性可以被用来给一个已有的服务做广告，向那些设计好的
终端广播，也可以向所有的个人计算机广播警告信息


一个通过tcp/ip连接以太网的计算机有一个和该网络接口相关的
ip地址。它与一个本网络的机器通信时，
只要直接向该计算机发送信息就你可以。如果要和网外的，在Internet
上的其他机器通信，就必须把信息先发送到一个本地网络上的路由器
然后由路由器决定信息包该方向哪里


为了知道哪些机器是本地的，哪些是远程的，网络软件会检查原计算机
和目的计算机IP地址的头几位(最有效部分)是不是相同。
每个网络接口上都有网络掩码表明需要比较几位。如果比较失败了，
开始的几位是不同的，那么信息包必须经过路由器。其他在范围
之内的计算机利用广播或直接传输则可以直接达到


１．５　　python网络编程

用python编写网路程序的时候，会哟两种情况：
１．有些程序是可以利用python中已经有一些协议模块(例如http,ftp)来写

２．而有些程序则需要自己写协议

１．５．１　　底层接口


python提供了访问底层操作系统socket接口的全部方法，需要的时候
这些接口可以提供功能。它还提供一些用于加密和认证通信的服务，
例如：ssl/tls/如果用c语言编写网络城西，会发现python的socket服务
与c类似　


１．５．１．1基本客户端操作

这是在现实世界中能找到的，可以运行的网络协议实现的最小程序。
它实现的是Gopher协议，一种web出现之前在Internet上非常流行的
协议。这个程序需要两个命令行参数：主机名和文件名，
实现从主机上请求相关文档的功能


操作很简单。它通过调用socket.socket()来建立一个Socket。
参数告诉系统需要一个Internet socket来进行TCP通信。
接着，程序连接远程主机并提供文件名。最后获得响应后，在屏幕上打印出啦

１．５．１．２　错误和异常

python会自动检查错误，并在有错误发生时产生异常。
python会检测到错误并产生一个socket.gaierror异常(请注意，
相关的文字和数字也许不同)
因为程序并没有特殊处理这个异常，所以程序会终止并打印出错的地方
和具体错误。

python中的send()函数，但是sendall()函数更方便。
如果有错误，它会产生异常；否则，则表明信息发送成功


１．５．１．３　　文件类对象

python中，文件对象的操作方法，reanline(),write(),read()等

python库支持文件和文件类对象。socket对象则不提供类似的接口，


python的确提供了一个makefile()函数来生成使用的文件类对象

makefile()函数有两个参数：
１．操作文件类的模式和缓存(buffering)的模式。操作文件类的模式辨明
你是只读，只写或既读又写("rw")

缓存主要用在磁盘文件，但是对于交互式的网络程序，它可能会阻碍程序的
运行，所以最好通过设置为０来关上它


既然能得到文件类对象，就可以用熟悉的方法。

write()和readline()它们的功能和一般的文件对象是一样的

１．５．１．４　基本服务器操作

第一件事就是调用socket.socket()函数来建立一个socket
接着为了运行，把socket设置成可复用的(reusable)
这个设置是可选的，

下一步绑定一个端口，这里选择端口51423
可以选择任何一个大于1024的端口。主机设置成空字符串，这样程序可以
接受来自任意地方的连接。接着调用listen()函数，这表明
已经开始等候来自客户端的连接了，同时设定每次最多只有一个等候处理
的连接。真正的服务器会允许一个很高的数字


主循环从对accept()函数调用的开始。程序会在连接了一个客户端后
马上停止。当某个客户端连接的时候，accept()返回两个信息：
一个新的连接客户端的socket和客户端的ip地址，端口号

这个例子中，使用了文件类对象，所以它的工作方式和前面的例子相似。
服务器接着显示出一些介绍性信息，从客户端读一个字符串，显示
一个应答，最后关闭客户端socket.
关闭socket很重要，否则客户端将不知道服务器已经结束通信，
而在服务器上会堆积很多旧的连接。当使用文件类对象的时候，
必须关闭文件对象和socket对象

首选需要运行服务器程序。然后再在终端或telnet应用程序
并连接localhost的51423端口

好像没有编写telnet协议，但是telnet客户端你也能
通信，可以进骨干这个基本服务器程序可以运行，但是它
没有什么用处


１．５．２　高级接口


经常使用的HTTP或imap,可能不需要编写这个底层的网络程序。。
python提供了很多协议模块，它们可以很大程度上简化编程任务

例如，不用自己编写代码来解析和理解http　header，
python中的httplib模块可以完成这个


gopherlib模块负责建立socket和连接，事实上，它甚至还负责
在返回send_selector()前调用makefile()

python中还有更高级的模块，为了处理url,python提供的模块
可以让你的代码和几种协议一起工作
１．６　总结


tcp/ip协议可以用于多种不同的传输,了；如：modems连接的网络和
以太网。每一个终端是靠唯一的IP地址和端口号来区分的

服务器通过一些事先知道的端口来侦听连接。当一个客户端连接时，
它的操作系统通常会选择一个事先不知道的端口号

有两种常用的数据传输协议：tcp,可以提供可靠性和完整的会话；
udp，用于小且简短但是快速的会话


大都数人用python编写网络程序，要么自己设计协议，要么用一些内置的
模块来实现一些已经存在的协议

对那些自己设计协议的人来说，python提供了全面的socket接口


第二章　网络客户端


编写使用网络服务的程序时，会发现经常要写网络客户端程序。如何在客户端实现一个应用程序协议。
如果Python没有一个可以实现想要的协议的模块，
或想要修改或扩展一个已经存在的Python模块的


２．１　理解socket


socket是操作系统中I/O系统的延伸部分，它可以使进程和机器之间的通信成为可能。
如果想完全地理解socket在当前系统上是如何工作的，
open(),read(),write(),close()。文件描述符一般是指一个文件或某个类似文件的实体


把对网络的支持加入操作系统，是一种扩展现有文件描述符结构的方法来实现的。
新的系统调用被加入并和socket一起工作，而很多现有的系统调用同样能和socket一起工作
一个socket允许您使用标准的操作系统和其他的计算机，以及您自己机器上的不同进程来通信

在某些方面，socket可以被看成一个标准的文件描述符。
在unix类的平台上，read(),write(),dup(),dup2(),close()这样的系统调用会像标准文件描述符那样为
socket工作。程序并不需要知道它正把数据写进一个文件，终端或一个TCPz连接


socket的确存在一些不同的工作方式。最明显的就是建立socket的方法。很多文件是通过调用open()函数来打开的，
但是socket是通过socket函数来建立的，并且还需要另外的调用来连接和激活它们。
recv()和send()这两个系统调用和read()和write()极为相似

send()和recv()调用提供了socket额外特有的功能

Python通过socket模块访问操作系统socket库的接口。建立socket的时候，只需要调用这个模块的函数和常量


2.2 建立socket

对于一个客户端程序来说，建立一个socket需要两步：
１．首先，需要建立一个实际的socket对象
２．　其次，需要把它连接到远程服务器上


在建立socket对象的时候，需要告诉系统两件事情：１．通信类型和协议家族。

通信类型指明了用什么协议来传输数据。协议的例子包括IPv4(当前的Internet标准)
IPv6(将来的Internet标准)
IPX/SPX(NetWare)和AFP(Apple文件共享)

目前为止，最通用的是IPv4,协议家族则定义数据如何被传输


Internet通信，通信类型基本上都是AF_INET(和IPv4对应)协议家族一般是表示TCP通信的SOCK_STREAM或
表示UDP通信的SOCK_DGRAM.

对于TCP通信，建立一个socket连接，一般用类似如下的代码


s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)


连接socket,一般需要提供一个tuple,它包含远程主机名或IP地址和远程端口。

连接一个socket一般用类似如下的代码


s.connect(("www.example.com",80))


import socket

print("Creating socket....")


s = socket.socket()

注意，c语言的connect()函数需要远程计算机的ip地址，在python中，socket对象的connect()函数会根据
需要利用DNS把域名自动地转化为IP地址。但对端口号则不是这样


２．２．１　旋转端口号

大多数操作系统都会附带提供一份已知服务器端口号的列表，可以查询。Python的socket库包含一个getservbyname()的函数
它可以自动地查询。在Unix系统中，总是可以在/etc/services目录下找到这样的列表

为了查询这个列表，需要两个参数：协议名和端口名。

端口名是一个字符串，例如：http可以被转换为一个端口号。

2.2.2 从socket获取信息


一旦建立了一个socket连接，就可以从它那里得到有用的额信息

报错信息

第一条将显示本身的IP地址和端口号；
第二条将显示远程机器的IP地址和端口号

对于客户端来说，端口号是由操作系统分配的(也许是随机的)
所以，会发现每次运行这个程序的时候，端口号都不一样


２．３　利用socket通信

现在和socket的通信已经建立起来了，是利用它发送和接收数据的时候了
python提供了两种方法：socket对象和文件类对象。

socket对象提供了操作系统的send(),sendto(),recv()和recvfrom()

调用的接口。文件类对象提供了read(),write()和readline()这些更典型的python接口


有一些特殊的需求的时候，socket对象特别有用。例如：读写数据时，需要协议可以详细地控制时，
使用二进制协议传送固定带下数据时，数据超时需要特殊处理时；或是任何不止需要简单读写时，
当你编写UDP程序的时候，socket对象同样是很好的选择

文件类对象一般用于面向线性的协议，因为它能通过提供的readline()函数自动大多数的解析。
然而，文件类对象一般只对TCP连接工作得很好，对UDP连接反而不是很好。


这是因为TCP连接的行为更像是标准的文件，它们保证数据接收的精确性，
并且和文件一样是以字节流形式运转的。而UDP并不像文件那样以字节流形式运转。
相反，它是一种基于信息包的通信。文件类对象没有办法操作每个基本的信息包，
因而建立，发送和接收UDP信息包的基本机制是不能工作，并且错误检查也是很困难的


２．４　　处理错误

在python中，当网络出现错误的时候，socket会出现异常。

具体的错误反馈取决于你的应用程序

２．４．１　socket异常

不同的网络调用会产生不同的异常。当处理socket对象时，如何捕获每一个普通的异常，

１．想要连接的主机名
２．服务器上的端口号或名字
３．　想从服务器请求的文件。

程序将连接上服务器，针对所请求文件的每个女子发送一个简单的http请求，显示结果

在整个过程中，它将尝试处理各种类型潜在的错误

异常处理只是简单地打印出一个友好的信息并终止运行。它捕获所有在这个例子中可能产生的和网络相关的
异常。Python的socket模块实际上定义了４种可能出现的异常：

１．与一般I/O和通信问题有关的socket.error
2. 与查询地址信息有关的socket.gaierror;
3. 与其他地址错误有关的socket.herror(和c语言中的h_error相关)
４．与在一个socket上调用settimeout()后，处理超时有关的socket.timeout


２．４．２　遗漏的错误

异常不是由sendall()函数产生的，而是由shutdown()函数产生的
sendall()函数立刻返回，但是shutdown()会一直等待，直到它能给你返回一个精确的退出代码


２．４．３　　文件类对象引起的错误


可以使用makefile()函数从socket得到一个文件类对象。
实际上，这个文件类对象调用实际的socket，所以由文件类对象产生的异常和socket自己的send()
和recv()函数产生的是一样的

注意对flush()的调用，从技术层面上来看，因为对makefile()的调用没有指定缓冲器(buffer)
所以这个调用并不是必须的，

２．５　　使用UDP

UDP通信几乎不使用文件类对象，因为它们往往不能为数据如何发送和接收提供足够的控制


上面的例子需要两个命令行参数：一个主机名和一个服务器的端口号。

它将连接服务器，接着提示输入一行要发送的文字。数据被发送后，它就进入了一个无限循环来等待回复。
因为无法知道什么时候服务器结束发送回复，

UDP和TCP客户端的区别：

１．当socket被建立的时候，程序调用的是SOCK_DGRAM,而不是SOCK_STREAM;
这就会向操作系统提示socket将使用UDP通信，而不是TCP

2.对socket.getservbyname()的调用寻找的是UDP端口号，而不是TCP的。
一个端口号对协议来说是特殊的，所以即使TCP使用119端口，一个完全不同的UDP应用程序也可以使用同一个端口

３．　程序没有办法探测到服务器什么时候发送完成。这是因为其实这没有实际的连接。。
对connect()的调用只是初始化了一些内在参数。同时，服务器也许不会返回任何数据，或数据
也许在传输过程中丢失，程序并没有智能地判断出这个问题，


２．６　总结


网络通信的基本接口是socket,它扩展了操作系统的基本I/O到网络通信。
socket可以通过socket()函数来建立，通过connect()函数来连接，
得到了socket，可以确定本地和远程端点的IP地址和端口号。
socket对不同的协议来说都是一种通用的接口，它可以处理TCP和UDP通信


python提供了两种和socket工作的接口：用于UDP和高级TCP目的标准socket接口，
以及用于简单TCP通信的文件类接口



第３章　网络服务器



前面编写网络客户端，建立一个socket,连接到一个服务器，接着和服务器通信

如何编写网络服务器。服务器的特点是等待来自客户端的请求，发送应答。
通常来说，服务器可以做任何事情，从分发web页面到交换e-mail.

最明显的是建立socket.在客户端频繁发生的突发事件。如何从头建立一个服务器程序，如何取得
客户端的信息，如何把活动记入日志，以及如何用不同的方式来运行你的服务器

3.1  准备连接
对客户端来说，建立一个TCP连接的过程分两步，包括建立socket对象以及调用connect()来建立一个和服务器的连接

对于服务器，这个过程需要４步：

１．　建立socket对象。
２．　设置socket选型(可选的)
3. 绑定到一个端口(同样，也可以是一个指定的网卡)
４．　侦听连接


3.1.1 建立socket对象

为了建立一个socket对象，使用和客户端中用到的同样的命令

s = socket.socket(sock.AF_INET,sock.SOCK_STREAM)

可以使用和客户端中使用的同一个socket对象



３．１．２　设置和得到socket选项

socket中，可以设置很多不同的选项。其中SO_REUSEADDR.

通常地，在一个服务器进程终止后，操作系统会保留几分钟它的端口，从而
防止其他进程(甚至包括本服务器自己的另外一个实例)在超时之前使用这个端口。如果
您设置SO_REUSEADDR的标记为true,操作系统就会在服务器socket被关闭或服务器
进程终止马上释放该服务器的端口。这样做，

s.setsockopt(socket.SQL_SOCKET,sock.SO_REUSEADDR,1)


Python定义setsockopt()和getsockopt()

setsockopt(level,optname,value)
getsockopt(level,optname[,buflen])

value参数的内容是由level和optname参数决定的。
level定义了哪个选项被使用。

通常情况下是SQL_SOCKET.用的socket选项。它还可以通过设置一个特殊协议号码
来设置协议选项。对于一个给定的操作系统，大多数协议选项都是明确的，

３．１．３　绑定socket

下一步是为服务器要求一个端口号，这个过程称为绑定。

每个服务器程序都有它自己的端口，

为了绑定一个端口，s.bind(('',80))

这条指令请求80端口，它是标准的HTTP(web)端口。然而，操作系统通常约定限制小于1024的
端口号，bind()函数的第一个参数是要绑定的IP地址。它通常为空，是可以绑定到所有的接口和地址

事实上，可以通过调用bind()函数来把客户端socket绑定到一个特定的ip地址和端口号。

想用特定的IP地址，对bind()调用s.bind(("192.168.1.1",80))

3.1.4 侦听连接

在实际接受客户端连接之前的最后一步就是调用listen()函数.这个调用通知操作系统准备接收连接。
它只有一个参数，这个参数指明了在服务器实际处理连接的时候，允许有多少个未决(等待)的连接在队列中等待。作为一个约定
一般设置为５
s.listen(5)


3.2 接受连接

大多数服务器都设计成运行不确定长的时间,客户端一般只有几个连接，并且会运行到任务完成或用户终止它们

通常使服务器连续运行的办法是小心地设计一个无限循环

通常情况下，无限循环是不好的，因为它们会耗尽系统的CPU资源，这里的循环是不同的：
当调用accept()的时候，它只在有一个客户端连接后才返回。
同时，程序停止时，并不使用任何CPU资源。一个停止并等待输入或输出的程序

３．３　处理错误
使用try...finanlly程序块关闭socket

在大型程序汇总，使用try...finanlly来确保socket被关闭


３．４　使用UDP

3.5 使用inetd或xinetd

３．５．１　配置inetd

inetd程序的配置文件/etc/inetd.conf

3.5.5 通过inetd使用UDP

3.6 通过syslog来记录日志
对于服务器管理元，通信状态的一个重要的内容是记录日志文件。

syslog是记录日志的一种普通且可以配置的基础工具。
syslog文件中的每一条日志都会自动记录日期，时间，主机名和程序名



3.6.1 在Python中使用syslog

３．７　避免死锁


第４章域名系统


域名系统(DNS)是一个分布式的数据库，它主要来把主机名转换成IP地址。DNS以及相关系统之所以存在，
１．　它可以使人们更容易记住，如www.apress.com,而不是IP65.215.221.149
2. 它允许服务器改变IP地址，但还用同样的名字

使用PyDNS直接查询DNS

4.1 进行DNS查询

DNS是一个全球的分布式数据库

4.2 使用操作系统查询服务
４．２．１　执行基本查询
４．２．２　执行反向查询


4.3 使用PyDNS进行高级查询

第５章　高级网络操作

Python对TCP/IP网络的支持，为不同类型的程序提供了很多有用的特性。
它们大多数既适用于客户端，也适用于服务器


1.半开放socket(Half-open sockets)，它可以使关闭一个方向上的通信
2. 超时(Timeouts),它在等待了一定的时间后，如果没有可以连接的挽留过则产生异常；；
３．　传送字符串和标记字符串结束的技巧
４.　网络字节命令，一般是用于C-based协议的通信
5. 广播(Broadcasts),它会同时向多个机器发送数据
6. 使用IPv6,下一代互联网协议
7. 绑定到特殊的地址或接口
8.使用poll()和select()同时查找多个不同的事件


第２部分

web service

第６章web 客户端访问

Internet一个重要的用途之一就是WWW,这也意味着它的主要协议---超文本传输协议(Hypertext Transfer Protocol,
即HTTP)是大多数程序员必须用到的。

python为编写web和http客户端提供了大量的模块


urllib2模块，实际上为不同协议的多个模块提供了一个通用的接口，其中HTTP显然是urllib2中最常用的协议

urllib2的功能

１．下载web页面
2. 在远程HTTP服务器上验证
3. 提交表单(form)数据
4. 处理错误
5. 与非HTTP协议通信

6.1 获取web页面

从远程服务器上下载一个web页面

首先，建立urllib2.Request对象。该对象用URL做参数，也可以在打开连接之前，
设置其他参数.当调用urlopen()的时候，对象被传进来，有了一个文件类对象。
该对象中还有一些额外的特性，它们可以是得到一些关于接收到的数据的其他细节



从geturl()得到的值与传入Request对象的值不一样，它在结尾处有一条斜线。
远程服务器做了一个HTTP的转向，urllib2自动跟随这个转向。其他行则显示了HTTP
header的信息

６．２　　认证

有些站点需要HTTP认证后才能访问。最普通的认证类型是基本认证，由客户端向服务器
发送一个用户名和密码。HTTP认证一般显示一个弹出窗口，来询问用户名和密码，
它与基于cookie和form的认证是不同的。

http认证经常与加密通信结合使用，后者使用ssl来确保诸如密码的认证信息安全。

6.3 提交表单数据

CGI脚本和其他交互式的服务器端程序经常从web客户端收到数据，一般是从表单(form)
你的Python客户端程序也可以发送这类数据，有两种方法提交表单数据：get和post

取决于html文档中<form>标签里面的方法参数


６．３.1  用get方法提交

提交表单的get方法是把表单苏剧编码至URL.在给出请求的页面后，加上一个问号(?)
接着是表单的元素。每个键和值对被"&"分隔。
有些字符需要被避免。因为URL中包含了全部的数据，所以get方法不太适合数据量比较大的情况



6.3.2 用POST方法提交

用POST方法提交表单数据有些不同。与get一样，数据需要被编码，与get不同的是，
数据不是被加到url上，而是以请求的一个单独部分发送的
当需要交换大量数据的时候，post是一个很好的方法。
并不需要服务器可以接受两种类型，很多服务器只可以接受一种类型


在post方法中，url是永远不会被修改的，附加的信息是通过第二个参数传递给urlopen()


6.4  处理错误


urllib2可以检测错误，并在有错误的时候产生异常。能够适当处理错误的关键，通常是捕获适当的异常


6.4.1  捕获连接错误


任何在连接过程中产生的异常要么都是urllib2.URLError的实例，要么是它的一个子类。

可以在catch语句中定义一个超类(superclass)

HTTPError异常本身是一种文件类对象，可以被用来读
为了得到HTTP服务器的错误文档，可以读取其他文件那样使用read()函数


６．４．２　　捕获数据错误

在读取数据的时候处理错误是更机警的。有两种问题会发生:
1. 通信错误，回会使socket模块在调用read()函数时产生socket.error.
2. 在没有通信错误的情况下发送的文档被删节


如果是通信错误，低级的错误会通过系统层传递上来，可以用socket错误的方法来处理


当一个程序发送文档的时候，服务器出现了问题，这样就会出现这种情况。而这时，
服务器的问题导致了远程socket被正常关闭，所以您的客户端程序会简单地收到一个文件结束标志


检查这个问题的方法是在服务器的问答中找到内容长度的报头(Content-Lenghth header)
如果提供了这个报头，可以对比接收到的数据长度和该报头中提供的长度。
如果两个数字不相符，就有问题了


内容长度的报头不总是被提供，特别是由CGI产生页面都不含此报头。非HTTP协议也经常不提供这个信息



在这种情况下，则没有办法检查文件是否被删节。

python的urllib2模块为从多种来源获得的数据提供了一个非常方便的接口。
默认情况下，它对具备或不具备ssl(Secure Socket　Layer)的HTTP,FTP和Gopher都支持

它的最基本用途就是从Internet上下载web页面和文件


有些站点需要经过认证后才能访问。通过构造自己的url访问者和定义密码管理的类，
可以在需要的时候提示用户输入认证信息


第７章解析 HTML 和XHTML

HTML是分级别的，这就意味着解析程序需要在标签出现的时候，就知道上下文的内容。如果
解析程序使用一些传统的而方法

第８章　 xml xml-RPC


8.2 使用dom

dom最主要的有点是它能呈现一个完整的，可以工作的xml文档树

第3部分
E-mail服务

第9章　E-mail的编写和编码


查看邮件信息

１．作为传统的邮件－－简单文本信息，接着是多种用途的Internet邮件扩展形式，即Multipurpose　Internet Mail Extensions(MIME) 后者在传统信息以上形成了一个层，允许携带附件，并允许从这两个方式中有选择地表示信息


9.1  理解传统信息


每一个传统的E-mail都包含有两个不同的部分：header和body.
header包含控制数据--例如：寄件人，目的地，信息的标题，而body包含信息本身。

第１0章　简单邮件传输协议(SMTP)
Simple Message Transport Protocol


邮件服务器使用SMTP 在Internet上传输邮件。邮件服务器允许使用smtp连接并把把
邮件保存在收件人的邮箱里。
smtp是一个主要发送，转寄和保存e-mail的协议，用户从服务器下载邮件则需要使用pop或IMAP

对Python来说，发送邮件通常使用smtp

启动发送邮件

linux程序要，使用/usr/sbin/sendmail


除了和本地机器或网络上的邮件服务器通信之外，还可以使用smtp与Internet山的远程服务器通信。
大多数情况下，

10.1 smtp库

smtplib模块来实现smtp的.smtplib模块以使SMTP的简单任务变得更容易
程序会调用几个命令行参数：smtp服务器的名称，一个发送这的地址和一个或多个收件人的地址

第11章　pop

pop(the pop office protocol)是一个简单协议，它可以用来从邮件服务器上下载邮件。
通过pop,可以从Internet提供上的服务器下载邮件，并通过邮件程序来阅读这些邮件


第４部分
多用途的客户端协议


第１３章　ftp


file transfer protocol,文件传输协议，从一个地方向另一个地方传输文件的协议。
它是双向的，即既可以用它上传文件，也可以用它下载文件。同时我们还可以通过ftp的指令
来执行删除，重命名文件，以及建立和阐述目录等到做。


13.3  以ascii模式下载文件

ftp传输文件主要以两种模式：ascii模式和二进制(映像)模式
在ascii模式中，文件是一行一行地传输的，这样客户端可以根据自己的操作系统，正确地给
每一行加上适当的结束符

13.4 以二进制模式下载文件


13.4.1  以高级二进制模式下载文件


13.5 　上传数据


13.5.1 以高级二进制模式上传

13.6 　处理错误


ftplib模块定义了一些的以市场


13.7 扫描目录

ftp协议提供两个方法来获得服务器上文件和目录的信息。在ftplib中它们是通过nlst()函数
和dir()函数来实现的

nlst()桉树返回规定目录下的一系列条目(信息)

dir()函数则可以从远方服务器上返回一个目录的列表


13.7.1 解析Unix目录列表

13.7.2 不用解析列表而得到信息

13.8 递归下载
13.9　操作服务器上的文件和目录
13.9.1  删除文件和目录

13.9.2 建立目录

第１４章　数据库客户端


14.1 sql和网络

１４．５ 事务

事务可以把多条对数据库的改动放到一条命令中

事务对于数据库的可靠性　而言很重要


１４．５．１　事件执行的性能


执行时间的性能很大程度取决与不同的服务器的。
在每个单独的命令后都提交是更新数据库的最慢的方法
一次提交非常大的时间会使服务器事件buffer溢出。并产生错误或宕机

14.6.3 处理那些不适合executemany()的情况

fetchall()函数可以获得结果集中的所有行,它返回一个顺序的list
list中的每个顺序都表示一个记录，而列表表示了顺序中的条目

fetchmany()本身限制每次调用返回的数量。必须在接收完全部数据之前继续调用它。
当没有数据返回时，fetchmany()将返回空

可以预先设置cursor的arraysize属性来决定每次返回的结果数，或可以传递给
fetchmany()一个指定的大小来覆盖原来的

fetchone()，这个函数将返回一个单独的行。如果没有数据了，它返回none，由于fetchone()每次只返回
一条单独的行，这样就不用担心内存了

第15章 ssl
1. 用远程服务器的认证功能(有时候也包括客户端)来帮助阻止伪装服务器攻击
２．　在通信的双向上加密数据流来阻止sniffing
3. 改变加密的钥匙，所以每次相同的数据表现得不同，这个可以阻止重复冲击
4. 数据完整型检查可以帮助阻止劫持，插入和删除攻击


第5部分　　服务器端框架


第16章　SocketServer

SocketServer是一个Python的框架，用来在服务器上处理来自客户端的请求。Python
已经包含了SocketServer.它充分利用了Python面向对象的优点来帮助实现服务器协议
定义一个

第17 章　SimpleXMLRPCServer



第18章　CGI

CGI,公用网关接口，是一种提供动态网站内容的方法。

CGI，是服务器独立和语言中立的。
CGI脚本可以运行在任何支持CGI的web服务器上，并且CGI脚本是可以由任何语言编写的。
CGI既不是一种网络协议，也不是它本身的一种库。而是一种说明信息是如何在web服务器和
产生数据的程序之间交换信息的说明书。可以被CGI编译并被web服务器执行的程序一般
被称为CGI脚本


第19章　mod_python

mod_python是在apache web服务器中嵌入了具有全部功能的python解释器。
这个模块通常被用来强劲而高效地产生动态网页，

第６部分

多任务处理

第20章 forking


为了能够同时为多个客户端服务，需要能够处理多个网络连接的方法。python提供了３个
主要的方法来达到这个目的：forking,threading,异步I/O(也被称为不闭塞的socket)

forking包括多任务－－－具有一种同时运行多个进程，或模拟这种情况的嫩李


20.1 理解进程



进程通常定义为"一个正执行的程序实例"
每一个进程都有一个唯一的，用来辨认的数字，被称为进程ID(PID)
在进程开始的时候，操作系统分配PID.

进程是多任务处理的基本单元，同时可运行多个进程。


20.2 理解fork()
系统用来实现forking的调用被称为foke().它是一个绝对唯一的调用。
Python中的大多数函数会只返回一次(有或没有值)
因为sys.exit()会终止程序，所以它就不会返回。
python的os.fork()是唯一返回两次的函数。在调用fork()之后，就同时存在正在运行的
程序的拷贝。但是第二个拷贝并不是从开始就重新开始的。
两个拷贝在对fork()调用后会继续－－－－进程的整个地址空间被拷贝。
这时可能会出现错误，而os.fork()可以产生异常，

对fork()的调用，返回针对原始(父)进程而产生新进程的PID.对于新(子)进程，
它返回PID0

dothefork()实际上也返回两次。任何返回两次的函数，在某种意义上，都可以调用os.fork()来实现

forking是实现多任务的一种最常见，最哈理解的方法，在服务器上使用fork就更常见了

这也是通常服务器对到来的新请求使用fork的原因

在一个fork之后，每个进程都含有一个不同的地址空间。更改一个进程中的变量不会影响其他进程中的变量，
这是和thread的一个主要不同。
这就可以使得你的代码减少被错误攻击的可能，这些错误可使服务器的其他进程被一个进程所干扰


在UNIX系统中，forking不只是用在网络应用上。例如，典型的程序运行方法(以及当你调用os.system()时，Python所做的)
就是先使用fork,接着使用某个os.exec...()函数来启动新程序。父进程会继续，检测子进程。
或它可以选择把本身的执行锁住，直到子进程使用某个wait()函数来终止



然而，forking是一种非常低级的操作。实际执行fork的继承会做少量的工作来确保所做的
正式操作系统希望你做的

20.2.1 重复的文件描述符

forking的副作用，重复的文件描述符。。
文件描述符可以指诸如socket,磁盘上的文件，终端(标准输入/标准错误)或某些其他文件类对象


因为一个进程的fork拷贝是一个准确的拷贝，它继承了父进程的所有文件描述符和socket


init的角色而

init程序总是系统中运行的第一个进程，它的PID是１。
它的主要角色是启动和关闭系统。在这里，init有另外一个角色。

如果一个进程死掉了，系统中还有该进程的子进程(可能是zombie)
系统将改变该子进程的父进程为PID 1---init.

init程序会像普通进程那样观察有zombie问题的子进程，这些子进程将被清理


第２１章　线程

forking，可以使多个请求被同时处理。forking是通过在一个进程中
建立两个完全独立的进程来实现。

python，也可以还是用threading

理论上，线程可以被看作是一个单独进程的不同部分在同时运行。

同时处理多任务请求

在有些时候，服务器的某个连接完全和其他连接没有关系。例如，FTP服务器就不需要在为客户端
提供服务的进程之间通信，每个进程只是提供下载和上传。
然而，有些时候这也不是绝对的。


传统的，不确切使用线程的程序被称为只含有一个线程或单线程程序，

可以使用线程的程序称为多线程程序，在程序中使用多于一个线程的方法被称为多线程编程


21.1 在Python中使用线程


Python中有两个多线程的模块：

thread,threading


注意，当使用多线程的时候，用什么来终止应用程序？

默认情况下，应用程序只有等全部线程终止后才会终止。
一般来说，编写网络程序的时候，通常会选择当主(控制)线程结束后，所有的线程也应该结束

21.1.1 使用共享变量

多线程中的变量是在所有线程中共享的

程序开始的时候定义了４个变量，它们的值都是50.
显示这些值，然后建立一个线程。该线程用不同的方法修改了每个变量，输出变量，然后终止。
主线程接着在join()和再次打印出值后取得控制权。
请注意主线程永远修改这些值

线程之间的通信的基本方法：设置变量

21.1.2 安全线程

用锁定解决线程紊乱的问题，在锁定文件的过程中flock()的角色。


在锁定文件的过程中flock()的角色。其实不用连接任何特定的文件或其他系统对象，就可以使用锁定


Python的threading模块提供了一个Lock对象。这个对象可以被用来同步访问代码。
Lock对象含有两个而方法：acquire()和release()

acquire()方法负责取得一个锁。如果没有线程正持有锁，acquire方法会立刻得到锁。否则，它
需要等锁被释放。在这两种情况下，一旦acquire()返回，调用它的线程就持有锁


release()会释放一个锁。如果有其他的线程正等待这个锁(通过acquire()),当release()
被调用的时候，它们中的一个线程就会被唤醒，也就是说，某个线程中的acquire()将返回


这个程序建立了４个新的线程。每个线程都会显示一条它存在的消息，得到锁，
延迟１秒钟，更新b的值，释放锁，然后终止。把释放锁的语句放在finally语句块
因为这样保证及时出现异常情况，锁也会被释放。


２１．１．３　设法访问共享且缺乏的资源


有时候，有些资源是一些线程必须访问的。也许这些资源同时有多个实例，所以一个简单的Lock是不够的，
也许包括服务器线程池。一旦一个服务器启动，它就会建立很多线程。
这些线程就称为worker线程，它们负责处理客户端。

在这种情况下，缺乏的资源是客户的连接。
这些线程将等待主线程接收并处理连接，然后这些线程会重启来等待下一个连接。
如果没有空闲的线程，服务器将把它加到一个队列中


在这种情况下，一个被称为旗语(semaphore)的同步对象非常有用。
Semaphone被设计成可以访问有限的资源。和Lock一样，Semaphore也有acquire()和release()两个。

但是它们实现的机制是不同的

Semaphore含有一个初始化的计数器(默认情况下)，且初始值为1.每次release()被调用的时候，计数器就增加
一次。每次acquire()被调用，计数器就减少一次。如果计数器是零值的时候acquire()被调用，　它就
只有在计数器等于或大于１的情况下此案返回(它只有等到有其他线程调用release()的时候才返回)


下面一个使用release()的例子，这个例子提供一个称为numbergen()的函数，它可以模拟一个有限的数字
资源(这可以联想到连接到某个服务器的客户端连接)
其他线程会消耗这些数字并作用于它们

这个程序包含４个线程：主线程，产生数字的线程和两个数字处理线程。
主线程负责建立其他所有的线程，然后就不做其他的工作了：数字产生线程会产生一些不连续的数字：
而数字处理线程得到并处理这些线程

Semaphore独享初始化为零。每当数字产生线程就产生了一个数字，它就会被放入队列中(使用Lock来确保
这个操作是安全的)，接着通过调用release()来表明它在Semaphore中存在。
注意，这并不能保证这个数字会被马上处理:它只是表明对于处理线程来说已经可以使用了。


生产者/消费者问题的一个实例。一个生产者/消费这问题包含一些线程来制造对象，而另外一些线程来消耗这些对象。
"生产者"是数字产生线程
"消费者"是计算器线程。
生产者/消费者通常用在不同线程使用是不用资源的时候
例如，某些线程可能需要大量的I/O操作来载入数据，而其他的线程需要大量的CPU来处理这些数据，通过拆分这些任务，
可以使更多的线程繁忙
队列(Queue)可以解决生产者/消费者问题


２１．１．４　避免死锁

当两个或等多线程在等待资源的时候会产生死锁，这种情况下它们的请求是不能得到满足的，
因为它们在互相等待。

避免死锁的原则：

１.一定要以一个固定的顺序来取得锁。
２．一定要按照与取得锁相反的顺序释放锁。

２１．２　编写含有线程的服务器

对于网络程序员来说，一个典型的问题是如何编写能够同时处理多个请求的高效服务器。
线程提供一种便利的方法


多数的多线程服务器有着同样的体系结构：主线程(Main Thread)是负责侦听请求的线程。
当它收到一个请求的时候，一个新的工作者线者线程(worker thread)会被建立起来，处理客户端
的请求。当客户端断开连接的时候，工作者线程会终止


handlechild()函数用来处理给定的客户端连接。当有客户端连接的时候，
一个新的线程被建立。当该线程启动的时候，它会调用hanlechild()
函数，把客户端的socket作为一个参数传递

使用线程客户保证主线程是可以接收UNIX信号的唯一线程－－并且
KeyboardInterrupt是作为UNIX上的SIGINT信号的结果而产生的。

对于工作这线程来说，不用考虑这些异常。而且，工作者线程在出现
错误的时候会终止


21.2.1  练习：使用线程的聊天服务器


既然可以非常容易在线程之间传递数据，那么线程对于那些需要全部客户端共享给某些
信息的服务器来说，是一个理想的实现方法。聊天服务器就是这种服务器。
可以扩展响应服务器，

使它成为一个简单的聊天服务器，即把一个客户端接收到的数据
发送给所有客户端，


其中的一种方法是在每个客户端线程中使用一个semaphore对象
和一个queue对象。需要为这些对象维护一个列表，并当线程启动
和终止的时候要在该列表中添加和去除它们。
当数据被发送之后，它就被加入到相关的大队列中，而semaphore也
被标志为信号

21.2.2  使用线程池


一些新的需求：例如，把建立新线程需要的性能消耗降到最小。
尽管消耗很小，但是有些应用程序是需要为一个新线程执行更多的
初始化工作－－－比如连接一个数据库服务器，这将对
性能产生很大的影响。
另外一个潜在的问题是资源利用。前一个程序会试图同时处理所有的请求。，
这对于多数服务器是没有问题的。但是对于某些流量大的网站，它们
也许希望同时只有1000个线程存在


线程池就是一个解决办法。线程池被设计成一个线程同时只为一个客户服务器
但是在服务器结束之后，线程并不终止。线程池中的线程要么
是事先全部建立起来，要么是在需要的时候被建立起来。

使用线程池的程序其实还是通过一个单独的线程来为客户端提供服务。
然而，不同的是，客户端断开连接的时候，线程并不终止，而是保持着，
等待为更多的连接提供服务。
线程池通常都有一个可以使用的线程数上限。如果达到了这个上限，
客户端然如果有连接，那么就会出现错误。
有些服务器还对forking使用这种策略，

线程池通常包含一下几个部分：
１．一个主要的侦听线程来接受和分派客户端的连接
２．　一些工作者线程用来处理客户端请求
３．　一个线程管理系统用来处理那些意外终止的线程


一个用线程池实现的响应服务器。维护着一个列表，该列表包括
正繁忙的线程，等待的线程和一个连接队列，并确保线程可以
正确地接收到连接。将分段呈现并

定义了一些全局变量，包括queue,它负责暂时存放不能处理的客户端
连接，还有两个列表用来跟踪线程的状态


第一个定义的函数是hanleconnection().当有新连接的时候，它将被
主程序的主循环，即listen()调用，首先，handleconnection()
会请求lockpool锁。然后它会检查是否到达了
系统的最大线程数。如果是，则关闭客户端socket并返回。
接下来，它检查是否所有的线程都繁忙。如果是，就建立一个新的线程


接着客户端socket被加入到队列(queue)中，同时semaphore
被释放－－－通知处理线程有可用的新连接。最后，线程池所被释放

startthread()函数和起那么的例子的线程代码类似，它的工作
主要是启动一个新的线程。


当新线程被建立的时候，threadworker()是第一个被调用的函数。它的
两个任务：
１．初始化waitinglist
2.　处理终止的线程。
注意，try程序块，它调用processclients()---实际上
是真正完成工作的函数。
在这个程序汇总，因为已经存在线程终止的时候，新的线程并不是
必须建立的，所以处理那些无论什么原因(异常等)而使线程终止
的线程　非常重要。

finanlly语句块就做这项工作。
无论何时当线程将要结束的适合，就执行finanlly语句块。
它会清理数据结构(把即将终止线程的引用去掉)
启动一个新的线程并最后终止

在processclients()中，能看到一个类似其他响应服务器的循环。
它以对semaphore调用acquire()开始。当返回的时候，它就知道
有客户端连接需要处理，所以它取得锁，获得连接，
更新数据结构并释放连接。接着它处理连接(它还有一个额外的特性，
通过这些特性可以测试线程存在的情形：如果发送DIE字符串，它就会
这样做)最后，在连接关闭后，
processclients()会再一次请求lockpool并更新数据结构

listener()函数运行在主线程中，它负责从客户端接收连接。
它在接收后把它们传递给handleconnection()


21.3 编写含有线程的客户端

fwrite()和span()函数都是用户接口的简单应用。uithread()
函数运行用户接口，并使用一个新的线程对象：Condition
在这个程序汇总，用户接口是以生产者/消费者方式实现的－－其中
主线程是为用户产生消息的生产者，而由接口线程接收并显示他们


Condition对象有一个特性，和一个潜在的锁。
uithread()函数－－－消费者－－－首先取得锁。
接着它进入一个while循环，循环直到队列中有了东西。
循环的每一次，他啊都会调用wait()
这个函数会释放锁并等待另一个线程调用notify()
但是它总是在返回前再次请求锁，这样可以不用付出代价
地安全访问队列


如果在嘟列中有实际的东西，将得到值(把它保存在msg中)
然后释放锁。队列中的东西被处理(显示)，而循环重复


msg()函数是等式的生产者一边。它开始申请得到锁。
接着它把消息添加到队列中，然后给其他线程发信号，
表示这里有消息(通过调用notify())并最后释放锁


程序其余的部分和其他程序类似。打印的调用被msg()的调用取代。
除此之外，程序的剩余部分都不知道有一个独立的线程在运行
(除了结尾处的shutdown程序)

21.4 总结

线程是一种支持服务器多连接的方法。和forking一样，它允许
多个代码同时执行。它和forking不同的地方是，
所有线程都有同样的地址空间，所以一个线程中的改动会影响其他的线程

大多数Python应用程序会使用threading模块来建立和使用线程。Threading
需要仔细对待同步问题。
Threading模块提供了写对象：Lock,当使用合适的时候，同时
只允许一个线程访问代码；Semaphore,它是被线程共享的，
可以帮助管理队列；以及Condition,可以在有事情发生的
时候给其他线程发送信号


线程可以用在客户端上，当有线程在网络上通信的时候，
它可以允许其他任务被执行。。

一个forking和线程的替代方法(异步I/O)
和forking及线程不同的是，异步I/O并不包含可以同时执行新的代码

第22 章　异步通信


前面介绍的forking和threading来一次后处理多个连接。
两种方法都是使操作系统同时执行多重代码来实现的，
尽管每个代码本身看上去想一个单独的socket程序在运行


事实上，forking和threading不是同时运行多个进程(或线程)
而是只运行一个进程。
这个进程会监视各种连接，在它们之间转换并按照需要为每一个连接
提供服务。这种被称为异步通信。
一种传统的方法是同步通信，其中对于I/O的处理是即时而又直接的。

为了实现异步通信。需要一些新的特性。
其中的一个特性就是不用停止所有程序就可以处理网络数据。
按照常规的办法，一个调用，例如read()，只有数据被完全从玩了过上
接收到，它才会返回。这并不好，因为在一个对read()调用返回之前，
进程是不能做任何事情的。Socket可以被设置为nonblocking方式。
在这种方式下，如果一个操作不能被立刻执行，调用会立刻返回一个专门的
错误代码，进程就可以继续。
总是试图没有准备好的socket来发送或接收数据是低效的，最好
使操作系统通知你什么时候socket是准备好的。
事实上，有两个函数可以完成：select()和poll()

为了使用它们，首先，需要通知操作系统你对哪些socket感兴趣。
在有一个或多个可是使用的socket之前，对它们调用是暂停的。
然后，你可以发现哪些socket是准备好的，接着就处理它们，
并重新等待。poll()函数正逐渐成为当前系统的首选



windows 上的异步I/O

在处理异步I/O方面，使用poll()的功能。
但是在windows上，就是使用Twisted

22.1  决定是否使用异步I/O

所有异步代码都有一个特征，那就是任何被阻塞一段时间的代码都要被去掉。
那些执行复杂计算或耗时的操作(例如数据库服务器)的服务器通常
不能使用完全的异步。另一方面，异步通信仅仅会因为新连接而增加很少的开销。
这就使它适合那些仅需要少许服务器端处理，就可以处理多个连接的服务器。
Web和FTP服务器就适合这种要求


asyncore和asynchat,可以帮助编写异步程序
另外一个需要考虑的重要问题是必须保持多少状态信息。例如一个FTP服务器，仅
需要保持很少的状态信息。它也许会保持恰当的工作目录，被传送的文件以及在该文件中的
位置。而某些服务器，例如游戏系统，就需要保存很多状态信息



22.2  使用异步通信

通过修改使它以异步通信方式来一次处理多个连接。
为了实现这个，需要加入一些东西，其中最值得注意的是明了状态的方法


在相应服务器中，明了状态意味着跟踪两个东西：客户端装置和将写入每个客户端的数据

在forking和threading中，是没有代码可以确切地处理的。
每个进程或线程处理每一个特定的连接，当连接关闭后，它们也消失。
此外，这些进程和线程使用正常(调度的)I/O,并维护这短暂的缓存区(buffer)
它们使用sendall()函数，而且在所有数据被全部发送之前是可以阻滞(block)的


数据可以以更小块发送，并且在全部发送之前是不能暂停的。
数据是保存在缓存器中的。对send()的调用将返回没有暂停而实际发送的字节数，
发送的是，需要从缓存器中减去该数字的字节。当有新数据到来时，
它们被加到缓存器的结尾处。
通过这种方法，异步响应服务器事实上有一个其他响应服务器都没有的特性：
它可以高效地同时发送和接收数据库，

例子中有一个响应服务器的代码，这个程序使用了一个类来维护每一个连接的信息，

主要的操作发生在stateclass类中，__init__()带一个mastersock参数，
并保存它。它还是初始化了两个数据结构。Buffer用来保存每个客户端的buffer,
socket保存每个客户端的socket.它们都是使用一个文件描述符数字作为索引的，
该数字是由操作系统定义的，而且对于每个socket来说是唯一的，
最后，建立并保存了一个poll()对象


fd2socket()方法是一个简单的助手(helper)方法。它就收一个
文件描述符(由poll()返回的)，并产生一个socket对象


当有新连接到来的时候，newconn()方法被调用。它会表明在相应的socket中
对什么感兴趣(读,写或两者都有)
给缓存器设置一个初始值(将被用来作为问候语)
并更新数据结构

当有数据到来时，readevent()被调用。它从socket那里读取数据，把它们添加
到缓存器，并确保对于该socket，已经声明了对读和写都感兴趣。这样就可以了，
因为只要收到数据，就会有数据被返回


在准备好要写某些数据，而系统可以保证send()函数将收到一块数据，并将立即返回的
时候，writeevent()方法就被调用。待发送的数据被发送，而实际
被发送的数据量从缓存器中去掉。如果缓存器为空，对socket的兴趣变为只读，
这样下次循环的时候，就不会尝试写数据

当出现错误的时候，errorevenv()被调用。它只是调用closeout()
这个函数可以把对socket的所有兴趣都从poll对象中去掉。
接着，它会关闭socket本身，并把它从数据结构中去掉

程序花费最多时间的函数是loop().程序在循环的顶部调用self.p.poll()
它是程序中被期望阻滞的调用。它只有当socket发生了一些我们关心的事情
时才会返回。这种行为为确保服务器只有在网络上真正发生了一些事情时，才会使用cpu资源

当poll()函数返回的时候，它返回一个tuple的列表。该列表中的每个tuple
对应一个连接，表明有些感兴趣的事情在该连接上发生。
因此，我们的任务就是检查每一个tuple并决定要做什么


Tuple包含一个socket的文件描述符和一个事件。


22.3 高级的服务器端使用

22.4 监控多个master socket


使用一个master socket.服务器在一个socket上侦听。
它只能处理一个正在侦听的socket,可以使用一个单任务服务器来侦听多个不同的端口。
事实上，标准UNIX的"superserver"守护进程(inetd)就是这样做到


22.5 在服务器上使用Twisted


它可以为服务器实现主要的循环
Twisted提供可以被重载的基类



22.6 总结


异步通信提供了一种一次处理多个连接的方法。和forking和threading不同，
异步通信实际上不会使服务器同时运行不同的代码。
相反，当有客户端到来的时候，它使用nonblocking的I/O和polling来为它们提供服务


异步I/O会处于一个主循环的中心，该循环等待事件的到来，
循环使用了poll()寻找文件描述符上的事件。当有事件发生的时候---例如
数据可以被读取，或可以写数据--程序直到发生了什么，
并执行相关的操作。poll()函数被设计成能够一次观察多个socket

它同样可以检测多个master socket,一个守护进程的例子就是这个


Twisted框架为异步服务器提供了很多工具。








